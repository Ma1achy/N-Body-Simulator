import pygame
import numpy as np
import csv
import os
import datetime
import time
"""
This script will visualise the simulation data generated by a barnes-hut simulation in Pygame and allows for interaction with the simulation, 
such as zooming, panning the camera, and toggling the display of the quadtree, bodies, and their vectors. This script also allows for the
saving of the rendered frames as .png files if the render variable is set to True. For large simulations, expect high memory usage and long
render times, with bad fps. Disable the consider_tree variable to reduce memory usage and increase fps, but the quadtree will not be displayed.
Disabling trails will also increase fps along with decreasing the window resolution.

The input path variable should be the directory of the simulation you want to visualise, and is found after the mainloop under "READ SIMULATION DATA" 
at the bottom of the script.

The following keys can be used to interact with the simulation:
- WASD to pan the camera
- E to reset the zoom and pan
- R to reset the camera 
- X to toggle the display of the centre of mass of each quad
- V to toggle the display of the force and velocity vectors of each body
- Q to toggle the display of the quads of the quadtree
- C to toggle the display of the debug rectangles
- F to toggle the display of the trails of the bodies
- ESC to quit the simulation
"""
#=================================================================FUNCTIONS=========================================================================

#--------------------------------------------------READING SIMULATION DATA-------------------------------------------------------
def read_bodies_cvs(path, bodiespath):
    """
    reads the bodies.csv file and returns a list of lists of the bodies data at each frame
    
    args:
    path (str): the directory of the simulation
    bodiespath (str): the name of the bodies.csv file
    
    returns:
    (list) a list of lists of the bodies data at each frame
    """
    bodies = []
    with open(os.path.join(path, bodiespath), 'r') as b:
        for row in csv.reader(b):
            frame = int(row[0])
            body_data = [frame] + list(map(float, row[1:]))
            while len(bodies) <= frame:
                bodies.append([])
            bodies[frame].append(body_data)
    return [frame_data for frame_data in bodies if frame_data]

def read_tree_cvs():
    """
    reads the tree.csv file and returns a list of lists of the tree data at each frame
    
    args:
    path (str): the directory of the simulation
    treepath (str): the name of the tree.csv file
    
    returns:
    (list) a list of lists of the tree data at each frame
    """
    tree = []
    with open(os.path.join(path, treepath), 'r') as t:
        for row in csv.reader(t):
            frame = int(row[0])
            tree_data = [frame] + list(map(float, row[1:]))
            while len(tree) <= frame:
                tree.append([])
            tree[frame].append(tree_data)    
    return [tree_data for tree_data in tree if tree_data]

#--------------------------------------------------RENDERING VISUALISATION--------------------------------------------------
def worldtoscreen(axes_size, WIDTH, HEIGHT, x, y, zoom_scale, camera_x, camera_y):
    """
    Convert world space coordinates to screen space coordinates with zoom, pan, and scale
    
    args:
    axes_size (float): the size of the axes in world space
    WIDTH (int): the width of the screen in pixels
    HEIGHT (int): the height of the screen in pixels
    x (float): the x coordinate in world space
    y (float): the y coordinate in world space
    zoom_scale (float): the zoom scale set by the user
    pan_x (float): the x component of pan
    pan_y (float): the y component of pan
    """
    #affine transformation matrix
    center_x = WIDTH // 2
    center_y = HEIGHT // 2
    
    aspect_ratio = WIDTH / HEIGHT
    transform_matrix = np.array([
        [zoom_scale / aspect_ratio, 0, center_x - center_x * zoom_scale + camera_x * zoom_scale],
        [0, zoom_scale, center_y - center_y * zoom_scale + camera_y * zoom_scale],
        [0, 0, 1]
    ])
    
    #convert the coordinates to screen space
    u = int(x * WIDTH // axes_size) - WIDTH // 2 
    v = int(y * HEIGHT // axes_size) - HEIGHT // 2 
    screen_coordinates = np.array([u, v, 1])
    
    #apply the affine transformation to the coordinates
    u, v, _ = np.dot(transform_matrix, screen_coordinates)
    
    return u, v

def lerpBlendRGBA(base, overlay, alpha): #this will look like shit, too bad!
    """
    linearly interpolate between two colours
    
    args:
    base (triple): a RGB colour to blend with the transparent overlay colour
    overlay (triple): a RGB colour to simulate the transparency of 
    alpha (float): 0 - 1, to simulate transparency of overlay colour
    
    returns
    (triple) a RGB colour
    """
    r1, g1, b1 = base
    r2, g2, b2 = overlay

    blend = lambda b, o: alpha * o + (1 - alpha) * b    # noqa: E731

    return (blend(r1, r2), blend(g1, g2), blend(b1, b2))

#----------------------------------------------------------MAIN RENDERING FUNCTION---------------------------------------------------------------------------
def draw(frame, bodies, tree, zoom_scale, camera_x, camera_y, draw_com, draw_vectors, draw_quads, draw_trails, consider_tree, debug): 
    #this function is probably the most unholy ambombination of spaghetti code fueled by caffine and sleep deprivation induced insanity I have ever written, 
    #pygame is so janky and has wasted so much of my time & sanity. I can't be bothered to refactor this into smaller functions lol so sorry for the mess.
    """
    Draw a frame of the simulation, the bodies with their forces and velocities, and the quads of the quadtree
    with their centre of mass and total mass, and the axes ticks.
    
    args:
    frame (int): the frame number to draw
    bodies (list): a list of lists of the bodies data at each frame
    tree (list): a list of lists of the tree data at each frame
    zoom_scale (float): the zoom scale set by the user
    camera_x (float): the x component of pan
    camera_y (float): the y component of pan
    draw_com (bool): whether to draw the centre of mass of each quad
    draw_vectors (bool): whether to draw the force and velocity vectors of each body
    draw_quads (bool): whether to draw the quads of the quadtree
    draw_trails (bool): whether to draw the trails of the bodies
    consider_tree (bool): whether to consider the tree when rendering and loading data
    debug (bool): whether to draw debug rectangles
    """
    MAX_PREVIOUS_FRAMES = 100
    WINDOW.fill((0, 0, 0))
    draw_axes_ticks(viewport, axes_size, zoom_scale, camera_x, camera_y, WIDTH, HEIGHT)
    trail_lines = []
    
    if consider_tree:
        #--------------------------------------------------DRAWING UNIVERSE BOUNDS-----------------------------------------------
        
        # Draw the root quad to represent the bounds of the universe, by drawing the first quad from the first frame in white every frame
        tlx , tly, = 0, 0
        brx, bry = axes_size, axes_size

        tlx, tly = worldtoscreen(axes_size, WIDTH, HEIGHT, tlx, tly, zoom_scale, camera_x, camera_y)
        brx, bry = worldtoscreen(axes_size, WIDTH, HEIGHT, brx, bry, zoom_scale, camera_x, camera_y)
        
        root_quad_rect = pygame.Rect(int(tlx), int(tly), int(np.abs(brx - tlx)), int(np.abs(tly - bry)))  # create a rectangle for the quad
        
        if viewport.colliderect(root_quad_rect):
            intersection_rect = root_quad_rect.clip(viewport)  # calculate the intersection between the viewport and quad rectangle

            # check if the viewport intersects with the quad rectangle
            if intersection_rect.width > 0 and intersection_rect.height > 0:
                pygame.draw.rect(WINDOW, (255, 255, 255), intersection_rect, 1)
                
        #--------------------------------------------------DRAWING QUADS-------------------------------------------------------
            
        for quad in tree[frame]:
            it, tlx, tly, brx, bry, m, cmx, cmy = quad

            tlx, tly = worldtoscreen(axes_size, WIDTH, HEIGHT, tlx, tly, zoom_scale, camera_x, camera_y)
            brx, bry = worldtoscreen(axes_size, WIDTH, HEIGHT, brx, bry, zoom_scale, camera_x, camera_y)
            cmx, cmy = worldtoscreen(axes_size, WIDTH, HEIGHT, cmx, cmy, zoom_scale, camera_x, camera_y)
            
            if draw_quads:
                quad_rect = pygame.Rect(int(tlx), int(tly), int(np.abs(brx - tlx)), int(np.abs(tly - bry))) #create a rectangle for the quad
                if viewport.colliderect(quad_rect): #check if the viewport and the quad rectangle overlap
                    intersection_rect = quad_rect.clip(viewport) #calculate the intersection between the viewport and quad rectangle
                    
                    #check if the viewport intersects with the quad rectangle
                    if intersection_rect.width > 0 and intersection_rect.height > 0:
                        pygame.draw.rect(WINDOW, (0, 255, 0), intersection_rect, 1)
            
            if draw_com:
                com_r = 5
                com_rect = pygame.Rect(int(cmx-com_r), int(cmy-com_r), 2*com_r, 2*com_r) #create a rectangle for the centre of mass
                if debug:
                    pygame.draw.rect(WINDOW, (255,140,0), com_rect, 1)
                    
                if viewport.colliderect(com_rect): #check if the viewport and the centre of mass rectangle overlap
                    intersection_rect = viewport.clip(com_rect) #calculate the intersection between the viewport and centre of mass rectangle
                    intersection_surface = pygame.Surface((intersection_rect.width, intersection_rect.height))
                    intersection_surface.set_colorkey((0, 0, 0))
                    pygame.draw.circle(intersection_surface, (255,140,0), (int(cmx - intersection_rect.x), int(cmy - intersection_rect.y)), com_r)
                    WINDOW.blit(intersection_surface, (intersection_rect.x, intersection_rect.y)) #only draw the part of the centre of mass that is in the viewport
 
    #--------------------------------------------------DRAWING BODIES-------------------------------------------------------
         
    for idx, body in enumerate(bodies[frame]):
        it, id, x, y, vx, vy, fx, fy, m, r = body

        x, y = worldtoscreen(axes_size, WIDTH, HEIGHT, x, y, zoom_scale, camera_x, camera_y)
        vx, vy = zoom_scale * vx * WIDTH / axes_size, zoom_scale * vy * HEIGHT / axes_size
        fx, fy = zoom_scale * fx * WIDTH / axes_size, zoom_scale * fy * HEIGHT / axes_size
        r = zoom_scale * r * np.sqrt(WIDTH ** 2 + HEIGHT ** 2) / axes_size

        if r < 1:
            r = 1

        body_rect = pygame.Rect(int(x - (r)), int(y - (r)), int(2 * r), int(2 * r))
        if debug:
            pygame.draw.rect(WINDOW, (255, 255, 0), body_rect, 1)

        if viewport.colliderect(body_rect):
            intersection_rect = viewport.clip(body_rect)
            intersection_surface = pygame.Surface((intersection_rect.width, intersection_rect.height))
            intersection_surface.set_colorkey((0, 0, 0))
            pygame.draw.circle(intersection_surface, (255, 255, 0), (int(x - intersection_rect.x), int(y - intersection_rect.y)), r)
            WINDOW.blit(intersection_surface, (intersection_rect.x, intersection_rect.y))

    #--------------------------------------------------DRAWING TRAILS-------------------------------------------------------

        if draw_trails:
            for j in range(max(0, frame - min(frame, MAX_PREVIOUS_FRAMES)), frame):
                prev_body = next((b for b in bodies[j] if b[1] == id), None)
                
                prev_x, prev_y = worldtoscreen(axes_size, WIDTH, HEIGHT, prev_body[2], prev_body[3], zoom_scale, camera_x, camera_y)
                age = frame - j  #calculate the age of the position
                alpha = int(255 - 255 * age / min(frame, MAX_PREVIOUS_FRAMES))
                
                prev_prev_body = next((b for b in bodies[j - 1] if b[1] == id), None)
                if prev_prev_body:
                    prev_prev_x, prev_prev_y = worldtoscreen(axes_size, WIDTH, HEIGHT, prev_prev_body[2], prev_prev_body[3], zoom_scale, camera_x, camera_y)

                    #thickness of the trail
                    thickness = 1
                        
                    #calculate the position and size of the line surface
                    line_width = max(abs(prev_x - prev_prev_x), thickness)
                    line_height = max(abs(prev_y - prev_prev_y), thickness)

                    line_surface = pygame.Surface((line_width, line_height), pygame.SRCALPHA)
                    #adjust the position based on the direction of the line
                    line_rect = line_surface.get_rect()
                    line_rect.topleft = (min(prev_x, prev_prev_x), min(prev_y, prev_prev_y))

                    #extend the line_rect to ensure it is visible
                    line_rect.inflate_ip(thickness, thickness)

                    #check if the line surface is intersecting with the viewport
                    if viewport.colliderect(line_rect):
                        
                        #calculate the intersection between the viewport and line surface
                        intersection_rect = viewport.clip(line_rect)
                        intersection_surface = pygame.Surface((intersection_rect.width, intersection_rect.height), pygame.SRCALPHA)
                        intersection_surface.set_alpha(alpha)
                        
                        if debug:
                            pygame.draw.rect(WINDOW, (255, 255, 0), intersection_rect, 1)
                            
                        line_start = pygame.Vector2(int(prev_x), int(prev_y))
                        line_end = pygame.Vector2(int(prev_prev_x), int(prev_prev_y))

                        clipped_line = pygame.Rect(viewport).clipline(line_start, line_end)

                        if clipped_line:
                            trail_lines.append({
                                'age': age,
                                'start': clipped_line[0],
                                'end': clipped_line[1],
                                'color': (255, 255, 0),
                                'alpha': alpha,
                                'thickness': thickness
                            })
                            
            #reorder the lines based on age
            trail_lines.sort(key=lambda line: line['age'], reverse=True)

            #draw the ordered lines
            for line in trail_lines:
                r, g, b = lerpBlendRGBA((0, 0, 0), line['color'], line['alpha'] / 255) #pygame doesn't suport per-surface alpha blending so I have to fake it, stupid as fuck
                pygame.draw.line(WINDOW, (r, g, b), line['start'], line['end'], line['thickness'])
        
    #--------------------------------------------------DRAWING VECTORS-------------------------------------------------------    
                                                                                       
        if draw_vectors:
            
            if fx == 0 and fy == 0:
                return
            else:
                if fx == 0:
                    fx = 2
                if fy == 0:
                    fy = 2
                    
                force_vector = pygame.Vector2(int(x + fx), int(y + fy)) - pygame.Vector2(int(x), int(y))
                force_vector.normalize_ip()
                
                force_rect = pygame.Rect(int(x), int(y), int(force_vector.x * zoom_scale * 10), int(force_vector.y * zoom_scale * 10)) #create force vector bounding box
                force_rect.normalize()
                if debug:
                    pygame.draw.rect(WINDOW, (255, 0, 0), force_rect, 1)  #draw the force vector
                
                #check if force_rect is intersecting with the viewport
                if viewport.colliderect(force_rect):
                    intersection_rect = viewport.clip(force_rect) #calculate the intersection between the viewport and force rectangle
                    intersection_surface = pygame.Surface((intersection_rect.width, intersection_rect.height))
                    intersection_surface.set_colorkey((0, 0, 0))
                
                    line_start = pygame.Vector2(int(x), int(y))
                    line_end = pygame.Vector2(int(x + force_vector.x * zoom_scale * 10), int(y + force_vector.y * zoom_scale * 10))
                
                    clipped_line = pygame.Rect(viewport).clipline(line_start, line_end)

                    if clipped_line:
                        clipped_line_start, clipped_line_end = clipped_line
                        pygame.draw.line(WINDOW, (255, 0, 0), clipped_line_start, clipped_line_end, 2)  #draw the clipped force vector

                    
            #draw normalized velocity vector if the body is moving (non-zero velocity)
            if vx == 0 and vy == 0:
                return 
            else:
                velocity_vector = pygame.Vector2(vx, vy)
                velocity_vector.normalize_ip()
                
                velocity_rect = pygame.Rect(int(x), int(y), int(velocity_vector.x * zoom_scale * 10)+2, int(velocity_vector.y * zoom_scale * 10)+2) #create velocity vector bounding box
                velocity_rect.normalize()
                if debug:
                    pygame.draw.rect(WINDOW, (0, 0, 255), velocity_rect, 1) 
                
                #check if velocity_rect is intersecting with the viewport
                if viewport.colliderect(velocity_rect):
                    intersection_rect = viewport.clip(velocity_rect)
                    intersection_surface = pygame.Surface((intersection_rect.width, intersection_rect.height))
                    intersection_surface.set_colorkey((0, 0, 0))
                    
                    line_start = pygame.Vector2(int(x), int(y))
                    line_end = pygame.Vector2(int(x + velocity_vector.x * zoom_scale * 10), int(y + velocity_vector.y * zoom_scale * 10))
                    
                    clipped_line = pygame.Rect(viewport).clipline(line_start, line_end)
                    
                    if clipped_line:
                        clipped_line_start, clipped_line_end = clipped_line
                        pygame.draw.line(WINDOW, (0, 0, 255), clipped_line_start, clipped_line_end, 2)  #draw the clipped velocity vector
    
    pygame.draw.rect(WINDOW, (255, 255, 255), viewport, 1) #draw the viewport in black to prevent clipped quad edges from being visible 

#--------------------------------------------------DRAWING AXES TICKS-------------------------------------------------------

def generate_ticks(axes_size, zoom_scale, WIDTH, HEIGHT, camera_x, camera_y):
    """
    Create a list of ticks to be displayed on the axes based on the zoom scale
    
    args:
    axes_size (float): the size of the axes in world space
    zoom_scale (float): the zoom scale set by the user
    WIDTH (int): the width of the screen in pixels
    HEIGHT (int): the height of the screen in pixels
    camera_x (float): the x component of pan
    camera_y (float): the y component of pan
    
    returns:
    (list) a list of ticks to be displayed on the axes
    """
    tick_density = max(1, 2 * int(zoom_scale * WIDTH / HEIGHT))
  
    tick_spacing = max(1, (axes_size) * zoom_scale / tick_density)

    #use range to generate ticks up to, but not exceeding axes_size * zoom_scale
    ticks = list(range(0, int(axes_size * zoom_scale) + 1, int(tick_spacing)))

    #filter ticks based on their world coordinates transformed to screen space
    filtered_ticks = []

    for tick in ticks:
        tick_x, _ = worldtoscreen(axes_size, WIDTH, HEIGHT, tick / zoom_scale, 0, zoom_scale, camera_x, camera_y)
        _, tick_y = worldtoscreen(axes_size, WIDTH, HEIGHT, 0, tick / zoom_scale, zoom_scale, camera_x, camera_y)

        #check if the transformed x-coordinate is within the screen bounds
        if 100 <= tick_x <= WIDTH - 100:
            filtered_ticks.append(tick)

        #check if the transformed y-coordinate is within the screen bounds
        if 100 <= tick_y <= HEIGHT - 100:
            filtered_ticks.append(tick)

    return filtered_ticks


def draw_axes_ticks(viewport, axes_size, zoom_scale, camera_x, camera_y, WIDTH, HEIGHT):
    """
    Draws the axes ticks and their labels on the screen
    
    args:
    viewport (pygame.Rect): the viewport
    axes_size (float): the size of the axes in world space
    zoom_scale (float): the zoom scale set by the user
    camera_x (float): the x component of pan
    camera_y (float): the y component of pan
    WIDTH (int): the width of the screen in pixels
    HEIGHT (int): the height of the screen in pixels
    """
    ticks = generate_ticks(axes_size, zoom_scale, WIDTH, HEIGHT, camera_x, camera_y)    
    #sort ticks in descending order based on x-coordinate
    ticks.sort(reverse=True, key=lambda tick: worldtoscreen(axes_size, WIDTH, HEIGHT, tick / zoom_scale, 0, zoom_scale, camera_x, camera_y)[0])

    displayed_labels = [] 

    for tick in ticks:
        tick_x, tick_y = worldtoscreen(axes_size, WIDTH, HEIGHT, tick / zoom_scale, 0, zoom_scale, camera_x, camera_y)

        #ensure the tick is within the x-bounds of the viewport
        if not viewport.colliderect(tick_x, 0, 1, HEIGHT):
            continue

        tick_x = max(viewport.left, min(viewport.right, tick_x))

        tick_rect = pygame.Rect(int(tick_x), int(viewport.y - 10), 1, 10)
        pygame.draw.rect(WINDOW, (255, 255, 255), tick_rect)

        #label the tick with its x-coordinate in world space
        tick_label = "{:.3g} AU".format(tick / (zoom_scale * 1.496e+11))
        tick_label_surface = pygame.font.SysFont(None, 18).render(tick_label, True, (255, 255, 255))
        tick_label_rect = tick_label_surface.get_rect()
        tick_label_rect.midtop = (int(tick_x), int(viewport.y - 24))

        #check if there's any label already displayed at the same position
        overlapping_labels = [label_rect for label_rect in displayed_labels if label_rect.colliderect(tick_label_rect)]

        #if there are overlapping labels, remove them from displayed_labels
        for label_rect in overlapping_labels:
            displayed_labels.remove(label_rect)

        WINDOW.blit(tick_label_surface, tick_label_rect)

        displayed_labels.append(tick_label_rect)
    
    #sort ticks in ascending order based on y-coordinate
    ticks.sort(key=lambda tick: worldtoscreen(axes_size, WIDTH, HEIGHT, 0, tick / zoom_scale, zoom_scale, camera_x, camera_y)[1])

    displayed_labels = []  #reset displayed_labels for y-coordinate sorting

    for tick in ticks:
        tick_x, tick_y = worldtoscreen(axes_size, WIDTH, HEIGHT, 0, tick / zoom_scale, zoom_scale, camera_x, camera_y)

        #ensure the tick is within the y-bounds of the viewport
        if not viewport.colliderect(0, tick_y, WIDTH, 1):
            continue

        tick_y = max(viewport.top, min(viewport.bottom, tick_y))

        tick_rect = pygame.Rect(int(viewport.x - 10), int(tick_y), 10, 1)
        pygame.draw.rect(WINDOW, (255, 255, 255), tick_rect)

        #label the tick with its y-coordinate in world space
        tick_label = "{:.3g} AU".format(tick / (zoom_scale * 1.496e+11))
        tick_label_surface = pygame.font.SysFont(None, 18).render(tick_label, True, (255, 255, 255))
        tick_label_rect = tick_label_surface.get_rect()

        #rotate only the y-axis label by 90 degrees before blitting
        if tick_x != camera_x:
            rotated_label = pygame.transform.rotate(tick_label_surface, 90)
            rotated_label_rect = rotated_label.get_rect()
            rotated_label_rect.midright = (int(viewport.x - 22), int(tick_y-rotated_label_rect.height/2))

            #center the rotated label onto the tick
            rotated_label_rect.move_ip(rotated_label_rect.width / 2, rotated_label_rect.height / 2)

            WINDOW.blit(rotated_label, rotated_label_rect)

        displayed_labels.append(tick_label_rect)

#=================================================================MAIN LOOP=========================================================================     
def main(frame, frame_rate, zoom_scale, camera_x, camera_y, render, consider_tree):
    """
    The main loop of the program
    
    args:
    frame (int): the frame number to draw
    frame_rate (int): the frame rate of the simulation
    zoom_scale (float): the zoom scale set by the user
    camera_x (float): the x component of pan
    camera_y (float): the y component of pan
    render (bool): whether to render the simulation as a gif
    consider_tree (bool): whether to consider the tree when rendering and loading data
    """
    global WIDTH, HEIGHT
    prev_width, prev_height = WIDTH, HEIGHT
    run = True
    draw_com = False
    draw_vectors = False
    draw_quads = False
    draw_trails = True
    debug = False
    paused = False
    camera_x, camera_y = WIDTH // 2, HEIGHT // 2 #initial camera position
    
    #key_state stores the state of the keys that are pressed
    key_state = {pygame.K_x: False, pygame.K_v: False, pygame.K_q: False, pygame.K_c: False, pygame.K_f: False}
    
    #main loop
    while run: 
        for event in pygame.event.get(): #check for events
            if event.type == pygame.QUIT:
                run = False
                pygame.quit()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    run = False
                    pygame.quit()

                if event.key in key_state:
                    if not key_state[event.key]:
                        key_state[event.key] = True

                        if event.key == pygame.K_x:
                            draw_com = not draw_com
                        if event.key == pygame.K_v:
                            draw_vectors = not draw_vectors
                        if event.key == pygame.K_q:
                            draw_quads = not draw_quads
                        if event.key == pygame.K_c:
                            debug = not debug
                        if event.key == pygame.K_f:
                            draw_trails = not draw_trails

            if event.type == pygame.KEYUP:
                if event.key in key_state:
                    key_state[event.key] = False

            if event.type == pygame.MOUSEWHEEL:
                zoom_scale += event.y * zoom_scale * 0.03
                if zoom_scale < 0.1:
                    zoom_scale = 0.1
                if zoom_scale > min_size:
                    zoom_scale = min_size

            #handle window resize event
            if event.type == pygame.VIDEORESIZE:
                WIDTH, HEIGHT = event.size
                pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
                viewport.width = WIDTH - 100
                viewport.height = HEIGHT - 100

                #adjust camera_x and camera_y based on the difference in size
                camera_x += (WIDTH - prev_width) // 2
                camera_y += (HEIGHT - prev_height) // 2

                prev_width, prev_height = WIDTH, HEIGHT

            #handle window minimize/restore events
            if event.type == pygame.WINDOWMINIMIZED:
                paused = True  #pause when the window is minimized
            elif event.type == pygame.WINDOWRESTORED:
                paused = False  #resume when the window is restored

        if not paused:
            keys = pygame.key.get_pressed()
            if keys[pygame.K_a]:
                camera_x += 10 / zoom_scale
            if keys[pygame.K_d]:
                camera_x -= 10 / zoom_scale
            if keys[pygame.K_w]:
                camera_y += 10 / zoom_scale
            if keys[pygame.K_s]:
                camera_y -= 10 / zoom_scale
            if keys[pygame.K_e]:
                zoom_scale = default_zoom_scale
            if keys[pygame.K_r]:
                camera_x, camera_y = WIDTH // 2, HEIGHT // 2
                zoom_scale = default_zoom_scale

            deltatime.tick(frame_rate)  # Use the specified frame rate
        
            frame_time_i = time.time()
            draw(frame, body_data_array, tree_data_array, zoom_scale, camera_x, camera_y, draw_com, draw_vectors,
                draw_quads, draw_trails, consider_tree, debug)
            frame_time_e = time.time()
            frame_time = frame_time_e - frame_time_i
            pygame.display.flip()

            print(
                f"dt = {deltatime.get_time():2f} \t| fps: {deltatime.get_fps():2f} | frame_time = {frame_time:10f}",
                end='\r', flush=True)

            if frame == len(body_data_array) - 1:
                run = False
                pygame.quit
                print("\nVisualisation finished\n")
            else:
                if render:
                    #save the current framebuffer as a png
                    pygame.image.save(WINDOW, os.path.join(frame_dir, f"frame_{frame}.png"))
                frame += 1

#=========================================================================================================================================================

consider_tree = True #whether to consider the tree when rendering and loading data
#--------------------------------------------------READ SIMULATION DATA-------------------------------------------------------
    
#simulation file to read from
path = r'results/2023-12-12 12-19-15 sim'

#file names of simulation data
parameterspath = 'parameters.csv'
bodiespath = 'bodies.csv'
treepath = 'tree.csv'

#read the parameters.csv file
with open(os.path.join(path, parameterspath), 'r') as f:
    reader = csv.reader(f)
    data = list(reader)
    axes_size, min_size, theta, max_iter, dt, save_rate = map(float, data[0])
    
body_data_array = read_bodies_cvs(path, bodiespath)

if consider_tree:
    tree_data_array = read_tree_cvs()
else:
    tree_data_array = []
#--------------------------------------------------VISUALISATION PARAMETERS--------------------------------------------------               
frame = 0
pygame.init() 

WIDTH, HEIGHT = 1600, 1400
WINDOW = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
pygame.display.set_caption(f"N Body Visualisation of {path}")
deltatime = pygame.time.Clock()

playback_speed = 0.5 #seconds per frame
#frame_rate = playback_speed/dt*save_rate #frames per second
frame_rate = 60

default_zoom_scale = 0.84
zoom_scale = default_zoom_scale
camera_x, camera_y = WIDTH//2, HEIGHT//2

viewport_width = WIDTH - 100
viewport_height = HEIGHT - 100
viewport = pygame.Rect(camera_x - viewport_width // 2, camera_y - viewport_height // 2, viewport_width, viewport_height)

#--------------------------------------------------------RENDERING--------------------------------------------------------
render = True
render_gif = True

if render: #save the rendered frames as a .png files
    dir = r'rendered'
    if not os.path.exists(dir):
        os.makedirs(dir)
        
    run_timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H-%M-%S")

    render_dir = os.path.join(dir, f"{run_timestamp} render")
    os.makedirs(render_dir, exist_ok=True)

    frame_dir = os.path.join(render_dir, "frames")
    os.makedirs(frame_dir, exist_ok=True)

    gif_path = os.path.join(render_dir, f"{run_timestamp} render.gif")

main(frame, frame_rate, zoom_scale, camera_x, camera_y, render, consider_tree)